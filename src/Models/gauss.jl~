include("source.jl")

function gauss!(phasor::Complex, x, v)
    dRa, dDec = sec2rad.*(v[1:2] .+ m.offset)
    w   = sqrt(1.0 - dRA*dRA - dDec*dDec)

    Nchn, Nobs = size(x)[2], prod(size(x)[3:5])
    x1, x2, x3 = (reshape(view(x, j,:,:,:,:), Nchn,Nobs) for j=1:3)
    @inbounds phasor[:] .= mean(asgaussian() .*
                                asphasor.(dRA.*x1 .+ dDec.*x2 .+ (w-1).*x3), dims=1)[1,:]
    return
end

gauss = Source(["dRA"=>0., "dDec"=>0., "Ellip"=>1., "Angle"=>0.], gauss!)

#=
function gausscomp(stokes, dsize, offset=[0, 0])
    Ndat = prod(dsize[2:5])
    sc   = Array{Tuple{Float64,Float64},4}(undef,dsize[2:5])
    sc  .= [(0, 0)]
    g0   = zeros(Ndat)
    Mdat = div(Ndat,64)
    gi, gr = zeros(Mdat), zeros(Mdat)

    function _gausscomp(x, p)
        p1, p2 = sec2rad.*(p[1:2] .+ offset)
        w   = sqrt(1.0 - p1*p1 - p2*p2)
        x1, x2, x3 = x[1,:,:,:,:], x[2,:,:,:,:], x[3,:,:,:,:]
        g0 .= @. exp( p[3]^2/4 * ( p[4]^2 *
                                   (cos(p[5])*x1 - sin(p[5])*x2)^2 +
                                   (sin(p[5])*x1 + cos(p[5])*x2)^2 ) )
        sc .= sincos.(p1.*x1 .+ p2.*x2 .+ (w - 1).*x3)
        gr .= reshape(mean(g0 .*  last.(sc), dims=1), Mdat)
        gi .= reshape(mean(g0 .* first.(sc), dims=1), Mdat)
        
        if stokes == "IQUV"
            A = vcat(p[6].*gr, p[6].*gi, p[6].*gr, p[6].*gi, p[7].*gr, p[7].*gi, p[7].*gr, p[7].*gi,
                     p[8].*gr, p[8].*gi, p[8].*gr, p[8].*gi, p[9].*gr, p[9].*gi, p[9].*gr, p[9].*gi)
        elseif stokes == "RRLL"
            A = vcat(p[6].*gr, p[6].*gi,  p[7].*gr,  p[7].*gi)
        elseif stokes in ["RR", "LL"] 
            A = vcat(p[6].*gr, p[6].*gi)
        else
            A = vcat(p[6].*gr, p[6].*gi,  p[6].*gr,  p[6].*gi)
        end
        return A
    end
end

function gausscompold!(stokes, dsize, offset=[0, 0])
    Ndat = prod(dsize[2:5])
    phas, g0 = zeros(dsize[2:5]), zeros(dsize[2:5])
    scr, sci = zeros(dsize[2:5]), zeros(dsize[2:5])

    Mdat = div(Ndat,64)
    gi, gr = zeros(Mdat), zeros(Mdat)

    function _gausscompold!(F::AbstractArray, x, p)
        p1, p2 = sec2rad.*(p[1:2] .+ offset)
        p3  = sec2rad*p[3]
        w   = sqrt(1.0 - p1*p1 - p2*p2)
        x1, x2, x3 = x[1,:,:,:,:], x[2,:,:,:,:], x[3,:,:,:,:]
        @inbounds phas .= p1.*x1 .+ p2.*x2 .+ (w - 1).*x3
        @inbounds scr .= cos.(phas)
        @inbounds sci .= sin.(phas)

        if p3 > 0
            @inbounds g0 .= @. exp(
                p3^2/4 * ( p[4]^2 * (cos(p[5])*x1 - sin(p[5])*x2)^2 +
                           (sin(p[5])*x1 + cos(p[5])*x2)^2 ) )
            @inbounds gr .= reshape(mean(g0 .* scr, dims=1), Mdat)
            @inbounds gi .= reshape(mean(g0 .* sci, dims=1), Mdat)
        else
            @inbounds gr .= reshape(mean(scr, dims=1), Mdat)
            @inbounds gi .= reshape(mean(sci, dims=1), Mdat)
        end
        
        if stokes == "IQUV"
            P = [p[6], p[6], p[6], p[6], p[7], p[7], p[7], p[7],
                 p[8], p[8], p[8], p[8], p[9], p[9], p[9], p[9]]
            A = [gr, gi, gr, gi, gr, gi, gr, gi, gr, gi, gr, gi, gr, gi, gr, gi]
        elseif stokes in ["IV", "QU"]
            P = [p[6], p[6], p[6], p[6], p[7], p[7], p[7], p[7]]
            A = [gr, gi, gr, gi, gr, gi, gr, gi]
        elseif stokes == "RRLL"
            P, A = [p[6], p[6], p[7], p[7]], [gr, gi, gr, gi]
        elseif stokes in ["RR", "LL"] 
            P, A = [p[6], p[6]], [gr, gi]
        else
            P, A = [p[6], p[6], p[6], p[6]], [gr, gi, gr, gi]
        end
        for j=1:length(P) @inbounds F[(j-1)*Mdat+1:j*Mdat] .= P[j].*A[j] end
        return
    end
end

function gaussexp!(g, c, s, p, x)
    j    = (blockIdx().x - 1)*blockDim().x + threadIdx().x
    
    if j <= length(c)
        w    = sqrt(1.0 - p[1]*p[1] - p[2]*p[2])
        phas = p[1]*x[1,j] + p[2]*x[2,j] + (w - 1)*x[3,j]
        c[j], s[j] = cos(phas), sin(phas)
        if p[3] > 0
            g[j] = exp( -1*p[3]^2/4 * ( p[4]^2 * (cos(p[5])*x[1,j] - sin(p[5])*x[2,j])^2 +
                                        (sin(p[5])*x[1,j] + cos(p[5])*x[2,j])^2 ))
        else
            g[j] = 1
        end
    end
    return nothing
end

function gausscomp!(stokes, xdata, ebuf, cbuf, sbuf, ubuf, offset=[0, 0])
    dtype, dsize = Float64, size(xdata)
    Ndat = prod(dsize[2:5])

    # println("Entering gausscomp!")
    if has_cuda()
        gexp = unsafe_wrap(CuArray{dtype}, convert(CUDA.CuPtr{dtype}, ebuf), Ndat)
        cexp = unsafe_wrap(Array{dtype}, convert(Ptr{dtype}, ebuf), Ndat)
        gcos = unsafe_wrap(CuArray{dtype}, convert(CUDA.CuPtr{dtype}, cbuf), Ndat)
        ccos = unsafe_wrap(Array{dtype}, convert(Ptr{dtype}, cbuf), Ndat)
        gsin = unsafe_wrap(CuArray{dtype}, convert(CUDA.CuPtr{dtype}, sbuf), Ndat)
        csin = unsafe_wrap(Array{dtype}, convert(Ptr{dtype}, sbuf), Ndat)
        guvw = unsafe_wrap(CuArray{dtype}, convert(CUDA.CuPtr{dtype}, ubuf), (3, Ndat))
        cuvw = unsafe_wrap(Array{dtype}, convert(Ptr{dtype}, ubuf), (3, Ndat))
        @inbounds cuvw .= reshape(xdata, 3, Ndat)
    else
        phas = zeros(dsize[2:5])
    end
    g0, scr, sci = zeros(dsize[2:5]), zeros(dsize[2:5]), zeros(dsize[2:5])

    Mdat = div(Ndat,64)
    gi, gr = zeros(Mdat), zeros(Mdat)

    function _gausscomp!(F::AbstractArray, x, p)

        # println("Entering _gausscomp!")
        p1, p2 = sec2rad.*(p[1:2] .+ offset)
        p3  = sec2rad*p[3]

        if has_cuda()
            Nthr = 256
            Ntot = Ndat == Int(floor(Ndat/Nthr)*Nthr) ? Ndat : Int((floor(Ndat/Nthr)+1)*Nthr)
            pars = CuArray([p1, p2, p3, p[4], p[5]])
            @cuda threads=Nthr blocks=div(Ntot,Nthr) gaussexp!(gexp, gcos, gsin, pars, guvw)
            synchronize()
            @inbounds g0  .= reshape(cexp, dsize[2:5])
            # println(g0[1:5])
            @inbounds scr .= reshape(ccos, dsize[2:5])
            @inbounds sci .= reshape(csin, dsize[2:5])
            @inbounds gr  .= reshape(mean(g0 .* scr, dims=1), Mdat)
            @inbounds gi  .= reshape(mean(g0 .* sci, dims=1), Mdat)
        else
            x1, x2, x3 = view(x,1,:,:,:,:), view(x,2,:,:,:,:), view(x,3,:,:,:,:)
            w   = sqrt(1.0 - p1*p1 - p2*p2)
            @inbounds phas .= p1.*x1 .+ p2.*x2 .+ (w - 1).*x3
            @inbounds scr .= cos.(phas)
            @inbounds sci .= sin.(phas)
            if p3 > 0
                @inbounds g0 .= @. exp(
                    -1 * p3^2/4 * ( p[4]^2 * (cos(p[5])*x1 - sin(p[5])*x2)^2 +
                                    (sin(p[5])*x1 + cos(p[5])*x2)^2 ) )
                @inbounds gr .= reshape(mean(g0 .* scr, dims=1), Mdat)
                @inbounds gi .= reshape(mean(g0 .* sci, dims=1), Mdat)
            else
                @inbounds gr .= reshape(mean(scr, dims=1), Mdat)
                @inbounds gi .= reshape(mean(sci, dims=1), Mdat)
            end
        end
        
        if stokes == "IQUV"
            P = [p[6], p[6], p[6], p[6], p[7], p[7], p[7], p[7],
                 p[8], p[8], p[8], p[8], p[9], p[9], p[9], p[9]]
            A = [gr, gi, gr, gi, gr, gi, gr, gi, gr, gi, gr, gi, gr, gi, gr, gi]
        elseif stokes in ["IV", "QU"]
            P = [p[6], p[6], p[6], p[6], p[7], p[7], p[7], p[7]]
            A = [gr, gi, gr, gi, gr, gi, gr, gi]
        elseif stokes == "RRLL"
            P, A = [p[6], p[6], p[7], p[7]], [gr, gi, gr, gi]
        elseif stokes in ["RR", "LL"] 
            P, A = [p[6], p[6]], [gr, gi]
        else
            P, A = [p[6], p[6], p[6], p[6]], [gr, gi, gr, gi]
        end
        for j=1:length(P) @inbounds F[(j-1)*Mdat+1:j*Mdat] .= P[j].*A[j] end
        return
    end
end

function gaussJcomp!(stokes, dsize, offset=[0, 0])
    Ndat = prod(dsize[2:5])
    sc   = Array{Tuple{Float64,Float64},4}(undef,dsize[2:5])
    sc  .= [(0, 0)]
    ell  = zeros(Float64,dsize[2:5])
    ellA = zeros(Float64,dsize[2:5])
    ell5 = zeros(Float64,dsize[2:5])
    x113 = zeros(Float64,dsize[2:5])
    x223 = zeros(Float64,dsize[2:5])
    g0   = zeros(dsize[2:5]...)
    Mdat = div(Ndat,64)
    zro  = zeros(Mdat)
    dnr, dni = zeros(Mdat), zeros(Mdat)
    d1r, d1i = zeros(Mdat), zeros(Mdat)
    d2r, d2i = zeros(Mdat), zeros(Mdat)
    d3r, d3i = zeros(Mdat), zeros(Mdat)
    d4r, d4i = zeros(Mdat), zeros(Mdat)
    d5r, d5i = zeros(Mdat), zeros(Mdat)
    dnr, dni = zeros(Mdat), zeros(Mdat)

    function _gaussJcomp!(J::Array{Float64}, x, p)
        p1, p2  = sec2rad.*(p[1:2] .+ offset)
        p3, p4, p6, p7  = sec2rad*p[3], p[4], p[6], p[7]
        s5, c5  = sincos(p[5])
        w   = sqrt(1.0 - p1*p1 - p2*p2)
        x1, x2, x3 = x[1,:,:,:,:], x[2,:,:,:,:], x[3,:,:,:,:]
        @. sc   = sincos(p1*x1 + p2*x2 + (w - 1)*x3)
        @. ell  = p4^2 * (c5*x1 - s5*x2)^2 + (s5*x1 + c5*x2)^2
        @. ellA = p3^2 * (c5*x1 - s5*x2)^2
        @. ell5 = p3^2/2*(1 - p4^2) * (s5*x1 + c5*x2)*(c5*x1 - s5*x2)
        @. x113 = x1 - p1/w*x3
        @. x223 = x2 - p2/w*x3

        if p3 > 0
            g0   .= @. exp( p3^2/4 * ell )
            d1r  .= reshape(mean(      -x113 .* g0 .* first.(sc), dims=1), Mdat)
            d1i  .= reshape(mean(       x113 .* g0 .*  last.(sc), dims=1), Mdat)
            d2r  .= reshape(mean(      -x223 .* g0 .* first.(sc), dims=1), Mdat)
            d2i  .= reshape(mean(       x223 .* g0 .*  last.(sc), dims=1), Mdat)
            d3r  .= reshape(mean(p3/2 .* ell .* g0 .*  last.(sc), dims=1), Mdat)
            d3i  .= reshape(mean(p3/2 .* ell .* g0 .* first.(sc), dims=1), Mdat)
            d4r  .= reshape(mean(p4/2 .*ellA .* g0 .*  last.(sc), dims=1), Mdat)
            d4i  .= reshape(mean(p4/2 .*ellA .* g0 .* first.(sc), dims=1), Mdat)
            d5r  .= reshape(mean(       ell5 .* g0 .*  last.(sc), dims=1), Mdat)
            d5i  .= reshape(mean(       ell5 .* g0 .* first.(sc), dims=1), Mdat)
            dnr  .= reshape(mean(               g0 .*  last.(sc), dims=1), Mdat)
            dni  .= reshape(mean(               g0 .* first.(sc), dims=1), Mdat)
        else
            d1r  .= reshape(mean(-x113.*first.(sc), dims=1), Mdat)
            d1i  .= reshape(mean( x113.* last.(sc), dims=1), Mdat)
            d2r  .= reshape(mean(-x223.*first.(sc), dims=1), Mdat)
            d2i  .= reshape(mean( x223.* last.(sc), dims=1), Mdat)
            d3r  .= 0
            d3i  .= 0
            d4r  .= 0
            d4i  .= 0
            d5r  .= 0
            d5i  .= 0
            dnr  .= reshape(mean(  last.(sc), dims=1), Mdat)
            dni  .= reshape(mean( first.(sc), dims=1), Mdat)
        end
        
        if stokes == "IQUV"
            P = [p[6], p[6], p[6], p[6], p[7], p[7], p[7], p[7],
                 p[8], p[8], p[8], p[8], p[9], p[9], p[9], p[9]]
            A = [gr, gi, gr, gi, gr, gi, gr, gi, gr, gi, gr, gi, gr, gi, gr, gi]
        elseif stokes in ["IV", "QU"]
            P = [p[6], p[6], p[6], p[6], p[7], p[7], p[7], p[7]]
            A = [gr, gi, gr, gi, gr, gi, gr, gi]
        elseif stokes == "RRLL"
            P = reshape([ p6,  p6,  p7,  p7,  p6,  p6,  p7,  p7,
                          p6,  p6,  p7,  p7,  p6,  p6,  p7,  p7,
                          p6,  p6,  p7,  p7,   1,   1,   1,   1,
                           1,   1,   1,   1], 4, 7)
            A = reshape([d1r, d1i, d1r, d1i, d2r, d2i, d2r, d2i,
                         d3r, d3i, d3r, d3i, d4r, d4i, d4r, d4i,
                         d5r, d5i, d5r, d5i, dnr, dni, zro, zro,
                         zro, zro, dnr, dni], 4, 7)
        elseif stokes in ["RR", "LL"] 
            P, A = [p[6], p[6]], [gr, gi]
        else
            P, A = [p[6], p[6], p[6], p[6]], [gr, gi, gr, gi]
        end
        for j=1:length(p)
            for k=1:length(P[:,j])
                J[(k-1)*Mdat+1:k*Mdat,j] .= P[k,j].*A[k,j]
            end
        end
        return
    end
end
=#
